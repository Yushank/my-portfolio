---
title: "Introduction to jwt authentication basics"
description: "JWT authentication is a very necessary step in building your website, to make it more secure and add role based routing features"
image: "image"
date: "2025-08-29"
---

# Building Authentication & Role-Based Routing in a Node.js + React Application

When I started this project, my goal was to implement a **secure authentication system** with **role-based routing** in a Node.js + React fullstack application. Beyond just signup/signin, I wanted to handle:

- 🔒 Access & refresh tokens
- 🔁 Automatic token refresh on expiry
- 🚫 Unauthorized request handling
- 🛡️ Role-based access (admin vs user)

Here’s how I designed and implemented it.

---

## 1. Backend: Hono + Prisma + JWT

I built the backend with **Hono** (a lightweight framework for Cloudflare Workers) and **Prisma** for database management.

- **Signup route**: Creates a new user in the database. If the user doesn’t exist, they’re signed up and automatically logged in.
- **Signin route**: Validates user credentials and returns **two tokens**:
  - **Access token** → short-lived, used for authenticated requests.
  - **Refresh token** → long-lived, used to generate new access tokens.

A simple **token validation middleware** looks like this:

```ts
export const authenticateToken = async (c: Context, next: Next) => {
  const authHeader = c.req.header("Authorization");
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return c.json({ error: "Access token required" }, 401);
  }

  try {
    const decoded = jwt.verify(token, c.env.ACCESS_SECRET) as {
      userId: string;
    };
    c.set("userId", decoded.userId);
    await next();
  } catch (error) {
    return c.json({ error: "Invalid or expired token" }, 401);
  }
};
```

## 2. Frontend: AuthContext

On the frontend, I created an AuthContext to manage login and logout. This ensures all components can access authentication state without prop drilling.

tsx
Copy code

```ts
export const AuthProvider = ({children}: {children: ReactNode}) => {
    const [accessToken, setAccessToken] = useState<string | null>(null);
    const [refreshToken, setRefreshToken] = useState<string | null>(null);

    const login = (access: string, refresh: string) => {
        setAccessToken(access);
        setRefreshToken(refresh);
        localStorage.setItem("accessToken", access);
        localStorage.setItem("refreshToken", refresh);
    }

    const logout = () => {
        setAccessToken(null);
        setRefreshToken(null);
        localStorage.removeItem("accessToken");
        localStorage.removeItem("refreshToken");
    }

    return (
        <AuthContext.Provider value={{accessToken, refreshToken, login, logout}}>
            {children}
        </AuthContext.Provider>
    );
};
```

login() stores tokens in localStorage.

logout() clears tokens and resets state.

Components like Signin/Signup call login(), while the logout button calls logout().

## 3. Axios Interceptors for Token Management

Instead of attaching tokens manually, I configured an axios instance with interceptors.

Every request → attaches the access token.

If backend returns 401 Unauthorized → interceptor automatically tries the refresh route.

If refresh works → retry the original request with new token.

If not → redirect to signin.

ts
Copy code
// Request interceptor

```ts
axiosInstance.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("accessToken");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error),
);

// Response interceptor
axiosInstance.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      const refreshToken = localStorage.getItem("refreshToken");
      if (refreshToken) {
        try {
          const response = await axios.post(
            `${BACKEND_URL}/api/v1/token/refresh`,
            { refreshToken },
          );
          const newAccessToken = response.data.accessToken;
          localStorage.setItem("accessToken", newAccessToken);

          originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;
          return axiosInstance(originalRequest);
        } catch (refreshError) {
          localStorage.clear();
          window.location.href = "/signin";
          return Promise.reject(refreshError);
        }
      } else {
        window.location.href = "/signin";
      }
    }
    return Promise.reject(error);
  },
);
```

This way, token expiry is handled silently in the background.

## 4. Role-Based Routing

To secure certain pages, I added role-based routes. Each user has a role field in the database (e.g., user, admin). This is embedded in the JWT payload.

ProtectedRoute → ensures a user is logged in.

ProtectedRouteAdmin → ensures the user is logged in and has the admin role.

Example:

tsx
Copy code

```ts
const ProtectedRouteAdmin = ({ children }: Props) => {
  const navigate = useNavigate();
  const accessToken = localStorage.getItem("accessToken");
  const decoded = accessToken ? jwtDecode<TokenPayload>(accessToken) : null;

  useEffect(() => {
    if (accessToken && decoded?.role !== "admin") {
      navigate(-1); // deny access and go back
    }
  }, [accessToken, decoded?.role]);

  if (!accessToken) return null;
  return children;
};
```

This allows:

/dashboard → any logged-in user

/admin → only admins

## 5. Auth Flow Diagram

Here’s a simplified diagram of the whole process:

pgsql

```ts
 [User Login/Signup]
        ↓
   Backend validates
        ↓
 [Access Token + Refresh Token]
        ↓
  Stored in localStorage via AuthContext
        ↓
 Every request → Access Token attached
        ↓
   Middleware checks token
        ↓
  If expired → Interceptor calls Refresh Route
        ↓
   New Access Token → Retry original request
        ↓
   If refresh fails → Redirect to /signin
```

## 6. Why This Matters

With this system in place, the application achieves:

✅ Secure authentication with JWT tokens

✅ Automatic token refresh (no manual re-login)

✅ Graceful handling of expired tokens

✅ Role-based routing for scalable user access

This project sharpened my skills in React, Node.js, JWT authentication, interceptors, and middleware design.
