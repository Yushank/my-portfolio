---
title: "Introduction to jwt authentication basics"
description: "JWT authentication is a very necessary step in building your website, to make it more secure and add role based routing features"
image: "image"
date: "2025-08-29"
---

# Building Authentication & Role-Based Routing in a Node.js + React Application

When I started this project, my goal was to implement a **secure authentication system** with **role-based routing** in a Node.js + React fullstack application. Beyond just signup/signin, I wanted to handle:

- ðŸ”’ Access & refresh tokens
- ðŸ” Automatic token refresh on expiry
- ðŸš« Unauthorized request handling
- ðŸ›¡ï¸ Role-based access (admin vs user)

Hereâ€™s how I designed and implemented it.

---

## 1. Backend: Hono + Prisma + JWT

I built the backend with **Hono** (a lightweight framework for Cloudflare Workers) and **Prisma** for database management.

- **Signup route**: Creates a new user in the database. If the user doesnâ€™t exist, theyâ€™re signed up and automatically logged in.
- **Signin route**: Validates user credentials and returns **two tokens**:
  - **Access token** â†’ short-lived, used for authenticated requests.
  - **Refresh token** â†’ long-lived, used to generate new access tokens.

A simple **token validation middleware** looks like this:

```ts
export const authenticateToken = async (c: Context, next: Next) => {
  const authHeader = c.req.header("Authorization");
  const token = authHeader && authHeader.split(" ")[1];

  if (!token) {
    return c.json({ error: "Access token required" }, 401);
  }

  try {
    const decoded = jwt.verify(token, c.env.ACCESS_SECRET) as {
      userId: string;
    };
    c.set("userId", decoded.userId);
    await next();
  } catch (error) {
    return c.json({ error: "Invalid or expired token" }, 401);
  }
};
```

## 2. Frontend: AuthContext

On the frontend, I created an AuthContext to manage login and logout. This ensures all components can access authentication state without prop drilling.

tsx
Copy code

```ts
export const AuthProvider = ({children}: {children: ReactNode}) => {
    const [accessToken, setAccessToken] = useState<string | null>(null);
    const [refreshToken, setRefreshToken] = useState<string | null>(null);

    const login = (access: string, refresh: string) => {
        setAccessToken(access);
        setRefreshToken(refresh);
        localStorage.setItem("accessToken", access);
        localStorage.setItem("refreshToken", refresh);
    }

    const logout = () => {
        setAccessToken(null);
        setRefreshToken(null);
        localStorage.removeItem("accessToken");
        localStorage.removeItem("refreshToken");
    }

    return (
        <AuthContext.Provider value={{accessToken, refreshToken, login, logout}}>
            {children}
        </AuthContext.Provider>
    );
};
```

login() stores tokens in localStorage.

logout() clears tokens and resets state.

Components like Signin/Signup call login(), while the logout button calls logout().

## 3. Axios Interceptors for Token Management

Instead of attaching tokens manually, I configured an axios instance with interceptors.

Every request â†’ attaches the access token.

If backend returns 401 Unauthorized â†’ interceptor automatically tries the refresh route.

If refresh works â†’ retry the original request with new token.

If not â†’ redirect to signin.

ts
Copy code
// Request interceptor

```ts
axiosInstance.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem("accessToken");
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error),
);

// Response interceptor
axiosInstance.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      const refreshToken = localStorage.getItem("refreshToken");
      if (refreshToken) {
        try {
          const response = await axios.post(
            `${BACKEND_URL}/api/v1/token/refresh`,
            { refreshToken },
          );
          const newAccessToken = response.data.accessToken;
          localStorage.setItem("accessToken", newAccessToken);

          originalRequest.headers.Authorization = `Bearer ${newAccessToken}`;
          return axiosInstance(originalRequest);
        } catch (refreshError) {
          localStorage.clear();
          window.location.href = "/signin";
          return Promise.reject(refreshError);
        }
      } else {
        window.location.href = "/signin";
      }
    }
    return Promise.reject(error);
  },
);
```

This way, token expiry is handled silently in the background.

## 4. Role-Based Routing

To secure certain pages, I added role-based routes. Each user has a role field in the database (e.g., user, admin). This is embedded in the JWT payload.

ProtectedRoute â†’ ensures a user is logged in.

ProtectedRouteAdmin â†’ ensures the user is logged in and has the admin role.

Example:

tsx
Copy code

```ts
const ProtectedRouteAdmin = ({ children }: Props) => {
  const navigate = useNavigate();
  const accessToken = localStorage.getItem("accessToken");
  const decoded = accessToken ? jwtDecode<TokenPayload>(accessToken) : null;

  useEffect(() => {
    if (accessToken && decoded?.role !== "admin") {
      navigate(-1); // deny access and go back
    }
  }, [accessToken, decoded?.role]);

  if (!accessToken) return null;
  return children;
};
```

This allows:

/dashboard â†’ any logged-in user

/admin â†’ only admins

## 5. Auth Flow Diagram

Hereâ€™s a simplified diagram of the whole process:

pgsql

```ts
 [User Login/Signup]
        â†“
   Backend validates
        â†“
 [Access Token + Refresh Token]
        â†“
  Stored in localStorage via AuthContext
        â†“
 Every request â†’ Access Token attached
        â†“
   Middleware checks token
        â†“
  If expired â†’ Interceptor calls Refresh Route
        â†“
   New Access Token â†’ Retry original request
        â†“
   If refresh fails â†’ Redirect to /signin
```

## 6. Why This Matters

With this system in place, the application achieves:

âœ… Secure authentication with JWT tokens

âœ… Automatic token refresh (no manual re-login)

âœ… Graceful handling of expired tokens

âœ… Role-based routing for scalable user access

This project sharpened my skills in React, Node.js, JWT authentication, interceptors, and middleware design.
