---
title: "Building a Blog System with Next.js and MDX: A Complete Guide"
description: "Learn how to build a powerful blog system using Next.js, MDX, and the filesystem. This tutorial covers everything from MDX compilation to dynamic routing."
date: "2024-11-14"
image: "/blog/mdx-tutorial.jpg"
---

# Building a Blog System with Next.js and MDX: A Complete Guide

If you've ever wondered how modern blogs manage content without a database, you're in the right place. In this comprehensive guide, we'll explore how to build a file-based blog system using Next.js and MDX, where your blog posts are simply files in your project directory.

## What is MDX?

Before diving into the code, let's understand what MDX is. **MDX** stands for **Markdown + JSX**. It's a format that allows you to write standard Markdown content while also being able to embed React components directly within your content.

Think of it this way:

- **Markdown** lets you write content with simple syntax (`# Heading`, `**bold**`, etc.)
- **JSX** is the syntax React uses to describe UI components
- **MDX** combines both, so you can write `<CustomButton />` right in your blog post!

Here's a simple example:

```mdx
# My Blog Post

This is regular markdown text.

<InteractiveDemo />

And back to markdown!
```

## Understanding the File System Approach

Traditional blogs store content in databases. Our approach is differentâ€”we store blog posts as `.mdx` files in a directory. Here's why this is powerful:

1. **Version Control**: Your content lives alongside your code in Git
2. **No Database Needed**: Simpler deployment and hosting
3. **Fast Builds**: Next.js can optimize these files at build time
4. **Easy Editing**: Just edit a text file, no admin panel needed

Our structure looks like this:

```
src/
  data/
    my-first-post.mdx
    building-with-nextjs.mdx
    about-me.mdx
```

## The Node.js File System Module

To read these files, we use Node.js's built-in `fs` (file system) module. Specifically, we use the promises version:

```typescript
import { promises as fs } from "fs";
```

This module gives us functions to:

- **Read files**: `fs.readFile()`
- **List directory contents**: `fs.readdir()`
- **Write files**: `fs.writeFile()` (not used here, but available)

The `promises` version is important because it returns Promises, which work perfectly with `async/await` syntax in modern JavaScript.

## What is next-mdx-remote?

`next-mdx-remote` is a library that does the heavy lifting of converting MDX into React components. The key function we use is `compileMDX`, which:

1. Takes raw MDX source text
2. Parses it into structured data
3. Extracts frontmatter (metadata at the top of the file)
4. Returns compilable React content

**Frontmatter** is the metadata section at the top of an MDX file, wrapped in `---`:

```mdx
---
title: "My Awesome Post"
description: "This post is great"
date: "2024-11-14"
---

Your content starts here...
```

## The Core Functions Explained

Now let's break down each function in our `mdx.ts` utility file.

### 1. getBlogFrontMatterBySlug

This function is the foundationâ€”it reads a single blog file and extracts only its metadata.

```typescript
export const getBlogFrontMatterBySlug = async (slug: string) => {
  const singleBlog = await fs.readFile(
    path.join(process.cwd(), "src/data", `${slug}.mdx`),
    "utf-8",
  );
```

**What's happening here:**

- `slug` is the filename without the `.mdx` extension (e.g., "my-first-post")
- `process.cwd()` returns the current working directory (your project root)
- `path.join()` safely combines path segments (handles `/` vs `\` on different OS)
- `fs.readFile()` reads the entire file as text (`"utf-8"` encoding)

```typescript
if (!singleBlog) {
  return null;
}
```

Safety checkâ€”if the file doesn't exist or is empty, return null.

```typescript
const { frontmatter } = await compileMDX<FrontMatter>({
  source: singleBlog,
  options: { parseFrontmatter: true },
});

return frontmatter;
```

Here we use `compileMDX` with TypeScript generics (`<FrontMatter>`) to tell it what shape our frontmatter should have. The `parseFrontmatter: true` option tells it to extract that YAML section at the top.

We destructure to get only `frontmatter` and ignore the compiled content (since we just want metadata here).

### 2. getBlogs

This function gets metadata for ALL blog posts in our directory.

```typescript
export const getBlogs = async () => {
  const files = await fs.readdir(path.join(process.cwd(), "src/data"));
```

`fs.readdir()` returns an array of all filenames in the directory:

```javascript
["my-first-post.mdx", "building-with-nextjs.mdx", "about-me.mdx"];
```

```typescript
const allBlogs = await Promise.all(
  files.map(async (file) => {
    const slug = file.replace(".mdx", "");
    const frontmatter = await getBlogFrontMatterBySlug(slug);
    return {
      slug,
      ...frontmatter,
    };
  }),
);
```

**This is doing several powerful things:**

1. `.map()` transforms each filename into a Promise
2. `.replace(".mdx", "")` strips the extension: "my-first-post.mdx" â†’ "my-first-post"
3. We call our previous function to get the frontmatter
4. `...frontmatter` spreads the frontmatter properties (title, description, date, etc.)
5. `Promise.all()` waits for ALL the async operations to complete

The result is an array like:

```javascript
[
  {
    slug: "my-first-post",
    title: "My First Post",
    description: "...",
    date: "2024-11-14",
  },
  // ... more blogs
];
```

### 3. getSingleBlog

This function retrieves both content AND frontmatter for a single blog post.

```typescript
export const getSingleBlog = async (slug: string) => {
  try {
    const singleBlog = await fs.readFile(
      path.join(process.cwd(), "src/data/", `${slug}.mdx`),
      "utf-8",
    );
```

Same file reading as before, but wrapped in `try/catch` for error handling.

```typescript
const { content, frontmatter } = await compileMDX<{ title: string }>({
  source: singleBlog,
  options: { parseFrontmatter: true },
});

return { content, frontmatter };
```

This time we destructure BOTH `content` and `frontmatter`:

- `content`: The compiled React component ready to render
- `frontmatter`: The metadata object

```typescript
  } catch (error) {
    console.error(`Error reading blog file for slug "${slug}":`, error);
    return null;
  }
```

If anything goes wrong (file not found, invalid MDX syntax, etc.), we log the error and return null gracefully.

### 4. getAboutMe

This is a specialized version of `getSingleBlog` for a specific file.

```typescript
export const getAboutMe = async () => {
  try {
    const aboutMe = await fs.readFile(
      path.join(process.cwd(), "src/data/", "about-me.mdx"),
      "utf-8",
    );
```

Notice we hardcode `"about-me.mdx"` instead of using a dynamic slug. This is perfect for static pages like "About Me" that have a fixed filename.

```typescript
const content = await compileMDX({
  source: aboutMe,
  options: { parseFrontmatter: true },
});

return content;
```

We return the entire compiled result, which includes both content and frontmatter.

## The Blog List Page

Now let's see how these functions are used in the actual pages. First, the page that lists all blogs:

```typescript
export default async function BlogsPage() {
  const allBlogs = await getBlogs();
```

We call `getBlogs()` which gives us an array of all blog metadata. In Next.js 13+, we can use `async` directly in Server Components!

```typescript
const truncate = (str: string, length: number) => {
  return str.length > length ? str.substring(0, length) + "..." : str;
};
```

A helper function to truncate long descriptions. If text is longer than `length`, cut it off and add "...".

```typescript
  return (
    <div className="flex min-h-screen items-start justify-start">
      <Container classname="min-h-screen p:4 md:pt-12 md:pb-10">
        <h1 className="text-primary text-3xl font-bold tracking-tight md:text-5xl">
          All Blogs
        </h1>
        <div className="flex flex-col gap-4 py-10">
```

Standard React/JSX for layout. Using Tailwind CSS classes for styling.

```typescript
          {allBlogs.map((blog, idx) => (
            <Link key={idx} href={`/blog/${blog.slug}`}>
```

**This is the magic of our system:**

- We loop through each blog object
- `<Link>` is Next.js's component for client-side navigation
- `href={/blog/${blog.slug}}` creates URLs like `/blog/my-first-post`
- When clicked, it navigates to that blog's dedicated page

```typescript
              <div className="flex items-center justify-between">
                <h2 className="text-primary text-base font-bold tracking-tight">
                  {blog?.title}
                </h2>
                <p className="text-secondary text-sm md:text-sm">
                  {blog?.date}
                </p>
              </div>
              <p className="text-secondary max-w-lg pt-2 text-sm md:text-sm">
                {truncate(blog?.description || "", 150)}
              </p>
            </Link>
          ))}
```

For each blog, we display:

- The title (from frontmatter)
- The date (from frontmatter)
- A truncated description (limited to 150 characters)

The `?.` is optional chainingâ€”it safely handles if a property is undefined.

## The Individual Blog Page

This page displays a single blog post's full content.

```typescript
export async function generateMetadata({
  params,
}: {
  params: Promise<{ slug: string }>;
}) {
  const { slug } = await params;
  const frontmatter = await getBlogFrontMatterBySlug(slug);
```

**generateMetadata** is a special Next.js function that creates the page's `<meta>` tags (for SEO, social sharing, etc.). We extract the slug from the URL params and fetch the frontmatter.

```typescript
if (!frontmatter) {
  return {
    title: "Blog not found",
  };
}

return {
  title: frontmatter.title,
  description: frontmatter.description,
};
```

If the blog doesn't exist, we set a fallback title. Otherwise, we use the frontmatter data for proper SEO.

```typescript
export default async function SingleBlogsPage({
  params,
}: {
  params: Promise<{ slug: string }>;
}) {
  const { slug } = await params;
  const blog = await getSingleBlog(slug);
```

The main page component. We extract the slug from the URL and fetch the complete blog data.

**How does `slug` get here?**

Next.js uses file-based routing. If you have a file at `app/blog/[slug]/page.tsx`, the `[slug]` part is a dynamic segment. When someone visits `/blog/my-first-post`, Next.js automatically sets `params.slug = "my-first-post"`.

```typescript
if (!blog) {
  redirect("/blog");
}
```

If the blog doesn't exist (maybe someone typed a wrong URL), redirect them back to the blog list.

```typescript
  const { content, frontmatter } = blog;

  return (
    <div className="flex min-h-screen items-start justify-center">
      <Container classname="min-h-screen p-4 md:pt-12 md:pb-10">
        <div className="prose mx-6 max-w-none">{content}</div>
      </Container>
    </div>
  );
```

Finally, we render the content! The `prose` class (from Tailwind Typography plugin) automatically styles all the markdown elements (headings, paragraphs, lists, etc.) to look beautiful.

The `{content}` variable is a React component returned by `compileMDX`, so it renders just like any other JSX.

## The Complete Data Flow

Let's trace what happens when a user visits `/blog/my-first-post`:

1. **Next.js routing** matches the URL to `app/blog/[slug]/page.tsx`
2. **Page component** extracts `slug = "my-first-post"` from params
3. **getSingleBlog()** is called with that slug
4. **fs.readFile()** reads `src/data/my-first-post.mdx` from disk
5. **compileMDX()** parses the MDX and extracts frontmatter
6. **Page component** receives `{ content, frontmatter }`
7. **React** renders the `content` component with proper styling
8. **User** sees the beautiful blog post!

## Performance Considerations

You might wonder: "Doesn't reading files on every request hurt performance?"

Great question! Here's the clever part:

- In **development**, files are read on each request (so you see changes immediately)
- In **production**, Next.js pre-renders these pages at build time (Static Site Generation)
- The compiled pages are served as static HTMLâ€”super fast!
- If you want, you can use Incremental Static Regeneration to rebuild pages periodically

## Extending This System

This foundational system can be extended in many ways:

### Add More Frontmatter Fields

```typescript
type FrontMatter = {
  title: string;
  description: string;
  date: string;
  image: string;
  author: string; // Add author
  tags: string[]; // Add tags
  readTime: number; // Add reading time
};
```

### Add Custom MDX Components

```typescript
const { content, frontmatter } = await compileMDX({
  source: singleBlog,
  options: { parseFrontmatter: true },
  components: {
    CustomButton: MyCustomButton,
    CodeBlock: MyCodeBlock,
  },
});
```

Now you can use `<CustomButton />` in your MDX files!

### Add Filtering and Sorting

```typescript
const allBlogs = await getBlogs();

// Sort by date (newest first)
const sortedBlogs = allBlogs.sort(
  (a, b) => new Date(b.date).getTime() - new Date(a.date).getTime(),
);

// Filter by tag
const techBlogs = allBlogs.filter((blog) => blog.tags?.includes("technology"));
```

### Add Search Functionality

```typescript
const searchResults = allBlogs.filter(
  (blog) =>
    blog.title.toLowerCase().includes(searchTerm.toLowerCase()) ||
    blog.description.toLowerCase().includes(searchTerm.toLowerCase()),
);
```

## Common Pitfalls and Solutions

### Issue: File Not Found Errors

**Solution:** Always use `try/catch` blocks and check if files exist before reading.

### Issue: MDX Syntax Errors

**Solution:** Validate your MDX syntax. Remember, it's stricter than regular Markdown.

### Issue: Slow Build Times

**Solution:** For blogs with 100+ posts, consider implementing pagination or lazy loading.

### Issue: Image Paths

**Solution:** Store images in `public/` and reference them with absolute paths: `/images/my-image.jpg`

## Conclusion

You now understand how to build a powerful, file-based blog system using Next.js and MDX. This architecture gives you:

- **Simplicity**: No database to manage
- **Performance**: Static generation for lightning-fast loads
- **Developer Experience**: Write in Markdown, commit to Git
- **Flexibility**: Easily extend with custom components

The beauty of this system is that your content is just filesâ€”version controlled, easily backed up, and portable. You could take these MDX files to any other framework that supports MDX if you wanted.

Start experimenting! Create your own MDX files, customize the frontmatter, and build the blog system that works perfectly for your needs.

Happy coding! ðŸš€
